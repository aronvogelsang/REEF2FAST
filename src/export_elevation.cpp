#include "export.hpp"
#include "common.hpp"
#include <fstream>
#include <iostream>
#include <set>
#include <map>
#include <cmath>
#include <vector>
#include <algorithm>

void write_surface_elevation(const InterpolatedWavefield& wf,
                             const std::string& filename,
                             double wave_dt, double wave_tmax) {
    std::ofstream file("../output/" + filename);
    if (!file) {
        std::cerr << "Error: Could not create " << filename << std::endl;
        return;
    }

    std::set<double> x_coords, y_coords;
    std::map<int, std::vector<WavefieldEntry>> time_data;

    size_t count_at_swl = 0;

    // Filter points near SWL and collect x/y for header
    for (size_t t = 0; t < wf.timesteps.size(); ++t) {
        std::vector<WavefieldEntry> surface_points;
        for (const auto& entry : wf.timesteps[t]) {
            if (round_to(entry.z) == 0.0) {
                WavefieldEntry rounded_entry = entry;
                rounded_entry.x = round_to(entry.x);
                rounded_entry.y = round_to(entry.y);
                surface_points.push_back(rounded_entry);
                x_coords.insert(rounded_entry.x);
                y_coords.insert(rounded_entry.y);
                count_at_swl++;
            }
        }
        time_data[t] = surface_points;
    }

    if (count_at_swl == 0) {
        std::cerr << "No points at SWL (z = 0.0) found in the interpolated wavefield.\n";
        return;
    }

    if (x_coords.size() < 2 || y_coords.size() < 2) {
        std::cerr << "Not enough unique X or Y points to compute grid spacing.\n";
        return;
    }

    double dx = *std::next(x_coords.begin()) - *x_coords.begin();
    double dy = *std::next(y_coords.begin()) - *y_coords.begin();

    std::cout << "Writing " << filename << "...\n";

    // -------- Header --------
    file << "This surface elevation file was generated by REEF2FAST\n";
    file << "Surface elevation relative to still water level (m)\n";
    file << "! " << format_scientific(wave_dt) << "  - WaveDT (s)\n";
    file << "! " << x_coords.size() << "  - Number of X grid points [NX*2 - 1]\n";
    file << "! " << y_coords.size() << "  - Number of Y grid points [NY*2 - 1]\n";
    file << "! " << format_scientific(dx) << "  - X grid spacing (m) [dX]\n";
    file << "! " << format_scientific(dy) << "  - Y grid spacing (m) [dY]\n";
    file << "!\n";
    file << "!\n";
    file << "!\n";
    file << "!\n";
    file << "! "; for (auto x : x_coords) file << format_scientific(x) << " "; file << "- X-Locations (m)\n";
    file << "! "; for (auto y : y_coords) file << format_scientific(y) << " "; file << "- Y-Locations (m)\n";

    // -------- Data --------
    for (const auto& [timestep, entries] : time_data) {
        std::map<double, std::vector<std::pair<double, double>>> y_to_xelev;

        // Group by y and store (x, elev)
        for (const auto& entry : entries) {
            y_to_xelev[entry.y].emplace_back(entry.x, entry.elevation);
        }

        // For each y-row, sort by x and write values
        for (auto& [y, x_elev_pairs] : y_to_xelev) {
            std::sort(x_elev_pairs.begin(), x_elev_pairs.end());

            for (const auto& [x, elev] : x_elev_pairs) {
                file << format_scientific(elev) << " ";
            }

            file << "! All X grid locations at Y = " << format_scientific(y)
                 << ", WaveTime = " << format_scientific(timestep * wave_dt) << "\n";
        }
    }

    file.close();
    std::cout << "File saved: " << filename << std::endl;
}